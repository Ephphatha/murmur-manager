To implement live updates of server state to interested web clients, I've implemented a simple comet server built on nginx and nginx_http_push_module.

For a guide on getting up and running on the module, see this URL:

	http://www.igvita.com/2009/10/21/nginx-comet-low-latency-server-push/

The actual config once this is set up is trivial:

    server {
        server_name your_server.com;

        root /var/www/websites;

		# This is the path to our Sinatra app, which provides pull-based server state for initial widget population
        location /murmur/tree {
            passenger_enabled on;
            passenger_base_uri /murmur/tree;
        }

		# This is the subscriber endpoint that widget clients subscribe to for updates
        location /murmur/listen {
            push_subscriber;
            push_subscriber_concurrency broadcast;
            set $push_channel_id $arg_id;
            default_type text/plain;
        }

		# This is the publisher endpoint that our comet-server.py publishes to.
        location /murmur/send {
            allow 127.0.0.1;
            deny all;
            default_type text/plain;
            set $push_channel_id $arg_id;
            push_publisher;
            push_message_timeout 15s;
        }
    }
	
With this implemented, all you have to do is start up comet-server.py, and you're off to the races. Any events generated by the server will be posted
to the HTTP push module as JSON packets, which will then be relayed to any interested clients. This provides realtime web browser-based updates of 
any changes in your Murmur server's state.

Why the comet server in Python and the initial state server in Ruby?

I prefer Ruby, but due to its threading architecture, the Ruby ICE bindings do not support server callbacks, so I went with Python instead. Adaptation of
the callbacks test script in the Murmur repo made development of the server trivial.